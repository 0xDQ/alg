% ----------------------------------------------------------------
% AMS-LaTeX Paper ************************************************
% **** -----------------------------------------------------------
\documentclass{amsart}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amscd}
\usepackage{amssymb}
\usepackage{mathtools}
% \usepackage{xy}
% ----------------------------------------------------------------
\vfuzz2pt % Don't report over-full v-boxes if over-edge is small
\hfuzz2pt % Don't report over-full h-boxes if over-edge is small
% THEOREMS -------------------------------------------------------
\newtheorem{thm}{Theorem}[section]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\newtheorem{alg}[thm]{Algorithm}
\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}
\numberwithin{equation}{section}
% MATH -----------------------------------------------------------
\newcommand{\Matrix}[4]{ \left( \begin{array}{cc}  #1 & #2 \\  #3 & #4 \\ \end{array} \right) }
\newcommand{\norm}[1]{\left\Vert#1\right\Vert}
\newcommand{\abs}[1]{\left\vert#1\right\vert}
\newcommand{\set}[1]{\left\{#1\right\}}

\newcommand{\NN}{\mathbb N}
\newcommand{\ZZ}{\mathbb Z}
\newcommand{\QQ}{\mathbb Q}
\newcommand{\RR}{\mathbb R}
\newcommand{\CC}{\mathbb C}
\newcommand{\isom}{\cong}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

\pagestyle{plain}
% ----------------------------------------------------------------
\begin{document}
\title[]{Algorithms Homework 1}%
\author{Evan Simmons \\
        Dept. of Mathematics \& Computer Science \\ University of California Santa Cruz}%
%\date{}
%\dedicatory{}%
%\commby{}%
\renewcommand{\abstractname}{Homework Option}
% ----------------------------------------------------------------
\begin{abstract}
I would like to choose the homework heavy option.
\end{abstract}
\maketitle
% ----------------------------------------------------------------

XXX: REVIEW
\section{} Suppose we are given a sorted array of $n$ distinct elements
that has been circularly shifted by $k$ elements. We want to find an
algorithm which runs in $O(log(n))$ time to find the maximum.

\lem \label{lem1}

Consider two elements in our circularly sorted array, $A[i]$ and $A[j]$
where $i < j$. The elements in $A[i..j]$ are sorted if
and only if $A[i] < A[j]$.

\proof{} 

Suppose the array slice $A[i..j]$ is not sorted, then $\exists k \ni
A[k] > A[k+1]$ where $i \leq k \leq j$. We know then that since the
array is circularly sorted that $\forall x \in A[i..k]$ and $\forall y
\in A[(k+1)..j]$ we have $x > y$. Clearly $A[i] \in A[i..k]$ and $A[j] y
\in A[(k+1)..j]$, therefore $A[i] > A[j]$

To show the converse, we simply note that for any sorted array, the
following holds:

$$ \forall i,j \ni i<j \Rightarrow A[i] < A[j] $$

\cor \label{cor1}

Consider two elements in our array $A[i]$ and $A[j]$ where $i<j$, the maximum
is in in $A[i..(j-1)]$ if and only if $A[i] > A[j]$

\proof 

Suppose $A[i] < A[j]$. Then by ~\ref{lem1}, $A[i..j]$ is sorted. Hence
$A[j]$ is larger than every element in $A[i..(j-1)]$, therefore the maximum
cannot be in $A[i..(j-1)]$.

Conversely suppose $A[i] > A[j]$, then by ~\ref{lem1} $A[i..(j-1)]$ is
not sorted. By the definition of a (not completely sorted) circularly
sorted array it has one consecutive pair of elements that are not
pairwise sorted, that pair is the maximum and minimum.

\alg{(CIRCULAR\_MAX)}

If the array consists of a single element, return that element.

Let $h = \floor{ \frac{n}{2} }$; compare the $A[0]$ and $A[h]$ elements. \\

Case (Less than): return the value of CIRCULAR\_MAX( $A[h..n]$ ) \\

Case (Greater than): return the value of CIRCULAR\_MAX( $A[0..(h-1)]$ ) \\

\proof

If an array consists of a single element, clearly that element must
be the maximum. If the first element $A[0]$ is less than the middle
element $A[h]$ then by ~\ref{cor1} the maximum occurs in the array slice
$A[h..n]$. However if $A[0]$ is greater than $A[h]$, then, again by
~\ref{cor1} the maximum occurs in $A[0..(h-1)]$.

\prop{The proposed algorithm runs in $O(log\ n)$ time.}

\proof

Since at each level of recursion we do only constant work, and are able
to eliminate half of the array, the complexity of the algorithm is
simply the height of the longest branch of the recursion tree. Recall
that the height of a tree is $log_{b} (n)$ where $b$ branching factor
and $n$ is the total number of elements (including those pruned).
Therefore the given algorithm is $\Theta( log n )$

Alternatively, we could have used the Master Theorem. The recurrence
relation is $T(n) = T(\frac{n}{2}) + n^0$ hence Case 2 applies and
yeilds $T(n) = \Theta (\log n)$
\\


XXX: IN PROGRES
\section{} If $A$ is an array of $n$ numbers. We wish to find:

$$ \max_{1 \leq j<k \leq n} (A[k] - A[j]).$$

\subsection{} Give an $O( n^2 )$ algorithm.
\alg{$O( n^2 )$}

For each element of the array, find its difference with each subsequent
element. Return the largest (positive) value of these differences.

\subsection{} Provide a more efficient algorithm.

At first I was stumped with this question, I quickly came up with
the linear time solution, but couldn't imagine a divide and conquer
algorithm. After all, a maximal subarray could cross any division point.
After looking through my Undergraduate algorithms book\footnote{Thomas
H. Cormen, "Introduction to Algorithms"}, I found an algorithm very similar
to what follows. I found the technique used intersting, and even more so that 
it is faster than the brute force method.

\alg{MAX\_DIFF}

If the array taken as argument is empty or contains only a single element, return zero.

Let $h = \ceil{n/2}$ where $n$ is the length of the array. Return the following:

\begin{align*}
  \max(\ & \text{MAX\_DIFF}( A[0..(h-1)] ), \\
        & \text{MAX\_DIFF}( A[h..(n-1)] ), \\
        & \text{MAX\_SPANNING\_DIFF}( A[0..(h-1)], A[h..(n-1)] )\ )
\end{align*}

where MAX\_SPANNING\_DIFF is defined as follows.

\proof 

Clearly a maximal subarray either includes an element or it does not.
Therfore there are three possible cases. The maximal subarray occurs
left of $h$, the maximal subarray occurs right of $h$, or the maximal
subarray includes $A[i]$. For the first two cases, since we call
MAX\_DIFF recursively, hence it suffices to prove only the third for the
call of $max$ to return the correct result. However, in the third case
we mererly call MAX\_SPANNING\_DIFF, therefore we are done.

\alg{MAX\_SPANNING\_DIFF}

We take as argument two arrays $A$ and $B$ where their lengths are $n_a$
and $n_b$ respectively. We return what follows by comparing each element in 
each array with it's relevant pivot ($n_a$ and $0$ respectively)

$$ \max_{0 \leq i \leq n_a -1}\ (A[n_a-1] - A[i]) + \max_{0 \leq j \leq n_b -1}\ (A[j] - A[0]) $$

\proof 

Certainly it is clear that we find the maximum pairwise
difference between each array's pivot and its respective elements. It
remains to show that the sum of these maximums in fact repesents the
difference between the first and last element of the maximal subarray,
which spans the two arrays passed as argument.


\subsection{} Provide a recurrence relation, and find an upper bound
using the Master Theorem.

The recurrence relation is:

$$ T( n ) = 2T(\tfrac{n}{2}) + n. $$

Let me explain. We split the array in half and find the maximal subarray
difference in both sides. We do this by calling MAX\_DIFF recursively on
both sides. Additionally we must scan each of the n elements at the current
level to find the maximum spanning differnce.

By invoking the Master Theorem we see that $a=2$, $b=2$, and $c=1$ which
means that Case 2 applies and we have $T( n ) = \Theta( n\ log\ n )$

\section{} Consider the following sorting algorithm: First sort the
first two thirds of the elements in the array. Next sort the last two
thirds of the array. Finally, sort the first two thirds again.

XXX: REVIEW
\subsection{} Provide an informal explaination of why this algorithm
returns a sorted array. \\

In short, this works because each partition can allow the swap of up to
half of it's elements. Consider the worst case where each element in the
bottom $\frac{1}{3}$ is strictly larger than the top $\frac{1}{3}$. It
is then possible to move the entire bottom $\frac{1}{3}$ into the top
$\frac{1}{3}$ exactly because its length is half of the subarray hence
can be swapped. Similarly for smallest elements.

\subsection{} Find a recurrence relation for the worst-case running time of this algorithm, then solve it using the Master Theorem.
$$ T(n) = 3 \cdot T( \tfrac{2}{3} n) + n^0. $$

Since $\log_{\frac{3}{2}} {3} > 0$, case 3 of the Master Theorem applies, and we get
$T(n) = \Theta ( n^{log_{\frac{3}{2}} {3}} )$

XXX: IN PROGRESS
\section{} Consider a monotonously decreasing function $f : \NN \rightarrow \ZZ$. We want to find:

$$ n = \min (\{i \in \NN \mid f(i) \leq 0 \}).$$ \\ 

Give an $O(log\ n)$ algorithm.

Clearly since we must consider a domain of infinite cardinality we cannot simply sub-divide the domain interval and proceed by computing the result for the constituent halves. Cleverly we consider the bins of exponential size, then binary search through that bin.

\alg{SEARCH\_BIN}

This is a simple binary search which takes a lower bound $x_1$, an upper bound$x_2$,
and a mapping $f$ from which to map the "indices" to values. We seek to find
the least index $x \in \NN$ such that $f(x) < 0$.
XXX: TODO

\proof
XXX: TODO

\alg{INFLECTION}

Our algorithm takes as argument index $x \in \NN$ and a function $f :
\NN \rightarrow \ZZ$. If $lastx$ is uninitialized, initialize it to $0$
If $x$ is uninitialized, initialize it to $2$. Otherwise save $x$ in the
variable $lastx$ and set $x = x^2$. Compute $f(x)$; if $f(x) < 0$, call
SEARCH\_BINARY with $lastx$, $x$ and $f$ Otherwise call INFLECTION again with
$x$, $f$ and (implicitly) $lastx$

\proof
XXX: TODO


\subsection{Complexity}

Since $f$ is a strictly decreasing function it must eventually cross the
x-axis. Let us assume for consistent notation that this happens at some
(unknown) point called $n$. In our algorithm we square the input $x$
value each time, this results in the inequality: $n \leq 2^k$ where $k$
is the number of recursions into INFLECTION. Hence we find the (clearly
negative) value of $f(2^k)$ where $2^k \geq n$ in $\O(log\ n)$ time. After this
we do binary search on the bin for which we know $n$ is in. And of course
as we all know binary search runs in $O( log\ n )$ time.


XXX: TODO
\section{}

\subsection{} Describe O(n) time algorithms for solving l-LMPS and r-RMPS

\subsection{} Given a O(n) time algorithm for l-LMPS describe a simple O(n2) algorithm for MPS.

\subsection{} Given O(n) time algorithms for l-LMPS and r-RMPS describe an O(n log n) divide-and- conquer algorithm for MPS.


\end{document}
% ----------------------------------------------------------------
