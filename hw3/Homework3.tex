% ----------------------------------------------------------------
% AMS-LaTeX Paper ************************************************
% **** -----------------------------------------------------------
\documentclass{amsart}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amscd}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{inconsolata}
\usepackage[shortlabels]{enumitem}
\usepackage{algorithmic}
% \usepackage{xy}
% ----------------------------------------------------------------
\vfuzz2pt % Don't report over-full v-boxes if over-edge is small
\hfuzz2pt % Don't report over-full h-boxes if over-edge is small
% THEOREMS -------------------------------------------------------
\newtheorem{thm}{Theorem}[section]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem*{lemstar}{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{claim}[thm]{Claim}
\newtheorem*{claimstar}{Claim}
\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\newtheorem{alg}[thm]{Algorithm}
\newtheorem*{algstar}{Algorithm}
\theoremstyle{remark}
\newtheorem{rmk}[thm]{Remark}
\newtheorem*{rmkstar}{Remark}
\numberwithin{equation}{section}
% MATH -----------------------------------------------------------
\newcommand{\norm}[1]{\left\Vert#1\right\Vert}
\newcommand{\abs}[1]{\left\vert#1\right\vert}
\newcommand{\set}[1]{\left\{#1\right\}}

\newcommand{\NN}{\mathbb N}
\newcommand{\ZZ}{\mathbb Z}
\newcommand{\QQ}{\mathbb Q}
\newcommand{\RR}{\mathbb R}
\newcommand{\CC}{\mathbb C}
\newcommand{\isom}{\cong}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

\let\null\varnothing

\pagestyle{plain}
% ----------------------------------------------------------------
\begin{document}
\title[]{Algorithms Homework 3}%
\author{Evan Simmons \\
        Dept.\ of Mathematics \& Computer Science \\ University of California Santa Cruz}%
%\date{}
%\dedicatory{}%
%\commby{}%
\renewcommand{\abstractname}{Homework Option}
% ----------------------------------------------------------------
\begin{abstract}
I have chosen the homework heavy option.
\end{abstract}
\maketitle
% ----------------------------------------------------------------
\section{Problem 6}
Given a sequence of words $W = \{w_0,w_1, \ldots , w_n \}$, we want to partition it into a set of lines where the character length of each line including spaces between the words is no more than $L$. Additionally we want each line to come as close to $L$ as possible.

Formally we seek to minimize the squared slack of the lines where slack is defined as:
$$ \sum_{w \in Line} (|w|+1) -1.$$

To keep track of the indices at which we want to insert newlines we will maintain a list of them called $K$.
\algstar
\begin{flalign*}
  & M\_S(K,0) = (K,0)&\\
  & M\_S(K,j) = minsnd \\
  &\ \ \textbf{for } k \in [0,j): \\
  &\ \ \ \ (K',mn) \gets M\_S(K++[k], k) \\
  &\ \ \ \ \textbf{return }(K', mn + SLACK^2(k+1,j))
  % \substack{maxsnd \\\ 0\leq k < j} \{ (\mbox{fst } M\_S(K, k)) \mbox{++} k,\ (\mbox{snd }M\_S(K, k)) + SLACK^2(k+1, j)) \} \\
\end{flalign*}
where $minsnd$ is the element with the smallest second term,

\begin{flalign*}
  &SLACK(i,j) =& \\
  &\hspace{.5cm} s \gets ( L - LEN(i,j) ) \\
  &\hspace{.5cm} \textbf{if } (s < 0):\ 
  \textbf{return } \infty \\
  &\hspace{.5cm}  \textbf{else}:\ 
  \textbf{return } s
\end{flalign*}
and,

\begin{flalign*}
  & LEN(i,j) =\ |w_i|\ \text{if i = j}& \\
  & LEN(i,j) = LEN(i, j-1) + LEN(i-1,j) + LEN(i-1,j-1) + 1.
\end{flalign*}

\proof{(Of Correctness)}
We seek a partitioning of the words so as to minimize the squared slack. We consider all possible (sequential) partitions of the sequence and take the partition which has minimum loss. This is exactly what M\_S does with the additional book-keeping of where the splits occur.

Since the subroutine SLACK is defined just as in the question, it remains only to show that LEN is correct. LEN is simply the sum of number of characters in a line (including spaces). We define LEN recursively so as to enable the use of previously calculated lengths.

Consider an matrix with $i$ rows and $j$ columns. Since $\forall i,j$ $i\leq j$ it is a lower triangular matrix. 


\claimstar The above algorithm runs in $O(n^2)$ time.
\proof{(Of Complexity)}



\section{Problem 10}
 
Suppose we have two machines on which we can run a job. We know the compute time availability for each machine over the next $n$ minutes. We want to choose what machine to run the job on for each minute if we can only run the job on one machine at a time. To switch machines, we must take a penalty of one minute before beginning the job on the new machine.

\subsection*{a.}
Consider the case where $A={2,1}$, and $B={1,10}$, the given algorithm will do the following:

\begin{enumerate}[1)]
  \item Take $a_1$ since it is larger than $b_1$.
  \item Take $a_2$ since there is no $b_3$.
\end{enumerate}

The result is $3$ whereas a correct algorithm should have output $11$.

\subsection*{b.}
Propose an algorithm which returns an optimal plan.

\algstar
Let
\begin{flalign*}
  & PLAN(P,\_,n) =   &\\
  & PLAN(P,M,t) = \\
  &\ \ (P_1,mx_1) \gets PLAN((P++[M],M,t+1) \\
  &\ \ (P_2,mx_2) \gets PLAN((P++[\bar{M}],\bar{M},t+1) \\
  &\ \ \textbf{if } max \{mx_1+M_t, mx_2\} == mx_1: \\
  &\ \ \ \ \textbf{return } (P_1, mx_1+M_t) \\
  &\ \ \textbf{else: } \\
  &\ \ \ \ \textbf{return } (P_2, mx_2)
\end{flalign*}
where $M$ is the current machine and $\bar{M}$ is the other machine.

To find the optimal plan, we compute:

$$ \text{fst . }maxsnd \{ PLAN([A],A, 2), PLAN([A],B, 2) \} $$

\proof{(Of Correctness)}
In PLAN, we consider all possible compute plan's, we recursively select the plan with maximal yield. 

\proof{(Of Complexity)}




\section{Problem 14}
\subsection*{a.}
Consider a sequence of graphs $\{G\}_{i=0}^b$. Suppose for $s,t \in V$ there is at least one $s-t$ path in all graphs. Provide a polynomial-time algorithm to find the shortest such path.
\algstar
We combine all graphs in the sequence into a new graph $H$ defined as:

$$ H = \left( V, \bigcap_{G(V,E) \in \{G\}} E \right). $$

We then run Dijkstra's on this new graph, and we have our result.

\subsection*{b.}
Give a polynomial-time algorithm to find a sequence of $s-t$ paths of minimum cost. We first let:

$$ H_{ij} = \left( V, \bigcap_{G(V,E) \in \{G\}_{i}^j} E \right). $$

Then we need only compute PATH(b):
\algstar
\begin{align*}
  & PATHS(-1) = -k \\
  & PATHS(0) = MCP(G_0) \\
  & PATHS(j) =
      min \left\{ \begin{array} l(P(j-1)) + PATHS(j-1) \\
          \displaystyle\min_{0 \leq i \leq j} \left\{ MCP(H_{ij}) \cdot (j-i+1) + PATHS(i-1) + k) \right\}
           \end{array} \right\} \\
\end{align*}

where MCP is the minimum cost $s-t$ path. (We may simply use Dijkstra's Algorithm.)

\section{Problem 20.}

We want to find the optimal allocation of $H$ hours among $n$ projects where $f_i$ is a non-decreasing function which given the hours of work as input returns the grade received for a given project.

\algstar
\begin{align*}
  & ALLOC(0,\_) = 0 \\ 
  & ALLOC(\_,0) = 0 \\
  & ALLOC(j,h) =
    \max_{0<k<h} \{ ALLOC(j-1, h-k) + f_j(k) \} 
\end{align*}

\section{Problem 26.}
We seek to order product in an optimal way such that we minimize our cost. We pay a flat rate of $K$ to place an order. We pay $c$ per item to store it for a month. We may store at most $s$ items. Finally we know the number of sales that will be made for the next $n$ months. Let $d_i$ denote the number of items sold in month $i$.

\algstar
\begin{align*}
  & PURCH(0) = 0 \\ 
  & PURCH(j) =
    \min_{0<i<j} \{ COST(i,j) + k + PURCH(i-1) \} 
\end{align*}

where:

\begin{align*}
  COST(i,j) = 
    \begin{cases}
      \displaystyle\sum_{l=i}^j d_l [c(l-i)] & \mbox{if } \displaystyle\sum_{l=i}^j d_k \leq s \\
      \infty & \mbox{o.w.}
    \end{cases}
\end{align*}

\section{Bonus: Problem 19.}

Given two sequences $x$ and $y$ we seek to determine if $s$ is an interleaving of $x$ and $y$.

\algstar
\begin{align*}
  & IL(k_x,k_y) =
  \begin{cases}
    k_x + k_y = |s| &\Rightarrow True \\
    match(k_x,k_y) = \{x,y\} & \Rightarrow IL(k_x+1, k_y)\ \vee\ IL(k_x, k_y+1) \\
    match(k_x,k_y) = \{x\} &\Rightarrow IL(k_x+1, k_y) \\
    match(k_x,k_y) = \{y\} &\Rightarrow IL(k_x, k_x+1) \\
    match(k_x,k_y) = \null &\Rightarrow False \\
  \end{cases} \\
\end{align*}
 where $m = match(k_x,k_y)$ and

\begin{align*}
  match(k_x, k_y) =& \{\mbox{if } x^\infty [k_x] == s[k_x+k_y-1] \Rightarrow x \} \\
   \cup &\{ \mbox{if } y^\infty [k_y] == s[k_x+k_y-1] \Rightarrow y \}
\end{align*}



\end{document}
